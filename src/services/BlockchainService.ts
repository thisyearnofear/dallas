/**
 * Enhanced Blockchain Service for Dallas Buyers Club
 * 
 * Handles interactions with Solana smart contracts:
 * - Case study submission with ZK proofs
 * - Validator staking & slashing mechanism
 * - EXPERIENCE token minting & burning
 * - Privacy sponsor integrations (Light Protocol, Arcium, etc.)
 * 
 * Privacy-first design:
 * - All health data encrypted before blockchain submission
 * - Platform cannot decrypt without user permission
 * - On-chain access control (patient-granted)
 */

import {
  PublicKey,
  Connection,
  Transaction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  TransactionInstruction,
  ComputeBudgetProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, BN, web3 } from '@coral-xyz/anchor';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction } from '@solana/spl-token';
import { SOLANA_CONFIG } from '../config/solana';

export interface CaseStudyData {
  encryptedBaseline: Uint8Array;
  encryptedOutcome: Uint8Array;
  treatmentProtocol: string;
  durationDays: number;
  costUSD: number;
  // Privacy sponsor integration fields
  lightProtocolProof?: Uint8Array;
  compressionRatio?: number;
  noirCircuitId?: Uint8Array;
  arciumMpcParams?: Uint8Array;
  usePrivacyCash?: boolean;
  useShadowWire?: boolean;
}

export interface ValidationData {
  caseStudyPubkey: PublicKey;
  validationType: 'quality' | 'accuracy' | 'safety';
  approved: boolean;
  stakeAmount: number;
  // ZK proof for validation without decryption
  noirProof?: Uint8Array;
  circuitParamsHash?: Uint8Array;
}

export interface TransactionResult {
  signature: string;
  accountPubkey?: PublicKey;
  success: boolean;
  error?: string;
}

export interface CaseStudyAccount {
  patientId: PublicKey;
  encryptedBaseline: Uint8Array;
  encryptedOutcome: Uint8Array;
  treatmentProtocol: string;
  durationDays: number;
  costUsd: number;
  createdAt: number;
  isApproved: boolean;
  approvalCount: number;
  validationScore: number;
  bump: number;
}

export class BlockchainService {
  private connection: Connection;
  private caseStudyProgramId: PublicKey;
  private experienceTokenProgramId: PublicKey;
  private experienceMint: PublicKey;

  /**
   * Initialize BlockchainService with program addresses from config
   */
  constructor() {
    this.connection = new Connection(SOLANA_CONFIG.rpcEndpoint[SOLANA_CONFIG.network], 'confirmed');
    this.caseStudyProgramId = new PublicKey(SOLANA_CONFIG.blockchain.caseStudyProgramId);
    this.experienceTokenProgramId = new PublicKey(SOLANA_CONFIG.blockchain.experienceTokenProgramId);
    this.experienceMint = new PublicKey(SOLANA_CONFIG.blockchain.experienceMintAddress);
  }

  /**
   * Create transaction instruction for case study submission
   * Includes privacy sponsor integrations
   */
  private createSubmitCaseStudyInstruction(
    payer: PublicKey,
    caseStudyPda: PublicKey,
    data: CaseStudyData
  ): TransactionInstruction {
    // Create instruction data buffer
    const instructionData = Buffer.alloc(1000); // Adjust size as needed
    let offset = 0;

    // Instruction discriminator (8 bytes) - this would be generated by Anchor
    instructionData.writeUInt32LE(0x12345678, offset); // Placeholder
    offset += 8;

    // IPFS CID placeholder (46 bytes)
    const ipfsCid = `Qm${Math.random().toString(36).substring(2, 46)}`;
    instructionData.write(ipfsCid, offset);
    offset += 46;

    // Metadata hash (32 bytes)
    const metadataHash = Buffer.from(Array(32).fill(0).map(() => Math.floor(Math.random() * 256)));
    metadataHash.copy(instructionData, offset);
    offset += 32;

    // Treatment category (1 byte)
    instructionData.writeUInt8(0, offset); // 0=experimental
    offset += 1;

    // Duration days (2 bytes)
    instructionData.writeUInt16LE(data.durationDays, offset);
    offset += 2;

    // Light Protocol proof (optional)
    if (data.lightProtocolProof && data.lightProtocolProof.length > 0) {
      instructionData.writeUInt16LE(data.lightProtocolProof.length, offset);
      offset += 2;
      data.lightProtocolProof.copy(instructionData, offset);
      offset += data.lightProtocolProof.length;
    } else {
      instructionData.writeUInt16LE(0, offset);
      offset += 2;
    }

    // Compression ratio
    instructionData.writeUInt16LE(data.compressionRatio || 1, offset);
    offset += 2;

    return new TransactionInstruction({
      keys: [
        { pubkey: caseStudyPda, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
      ],
      programId: this.caseStudyProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Submit encrypted case study to blockchain with privacy sponsor integrations
   */
  async submitCaseStudy(
    payer: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    caseStudyData: CaseStudyData
  ): Promise<TransactionResult> {
    try {
      // Derive PDA for case study account
      const timestamp = Math.floor(Date.now() / 1000);
      const [caseStudyPda, bump] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('case_study'),
          payer.toBuffer(),
          Buffer.from(timestamp.toString()),
        ],
        this.caseStudyProgramId
      );

      // Get recent blockhash
      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');

      // Create transaction
      const transaction = new Transaction({
        feePayer: payer,
        recentBlockhash: blockhash,
      });

      // Add compute budget instruction for complex operations
      transaction.add(
        ComputeBudgetProgram.setComputeUnitLimit({
          units: 400_000, // Increase for ZK proof verification
        })
      );

      // Add case study submission instruction
      const submitInstruction = this.createSubmitCaseStudyInstruction(
        payer,
        caseStudyPda,
        caseStudyData
      );
      transaction.add(submitInstruction);

      // Sign and send transaction
      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
        }
      );

      // Wait for confirmation
      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash,
          lastValidBlockHeight: (await this.connection.getLatestBlockhash()).lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }

      return {
        signature,
        accountPubkey: caseStudyPda,
        success: true,
      };
    } catch (error) {
      console.error('Case study submission error:', error);
      return {
        signature: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Fetch case study from blockchain
   */
  async fetchCaseStudy(caseStudyPubkey: PublicKey): Promise<CaseStudyAccount | null> {
    try {
      const accountInfo = await this.connection.getAccountInfo(caseStudyPubkey);
      if (!accountInfo) return null;

      // Decode account data (simplified - in real usage, use Anchor client)
      const data = accountInfo.data;

      // This is a placeholder - actual decoding would parse the Anchor account structure
      return {
        patientId: new PublicKey(data.slice(8, 40)),
        encryptedBaseline: new Uint8Array(data.slice(40, 10044)),
        encryptedOutcome: new Uint8Array(data.slice(10044, 20048)),
        treatmentProtocol: Buffer.from(data.slice(20048, 20552)).toString(),
        durationDays: data.readUInt32LE(20552),
        costUsd: data.readUInt32LE(20556),
        createdAt: Number(data.readBigInt64LE(20560)),
        isApproved: data[20568] === 1,
        approvalCount: data.readUInt32LE(20569),
        validationScore: data.readUInt32LE(20573),
        bump: data[20577],
      };
    } catch (error) {
      console.error('Error fetching case study:', error);
      return null;
    }
  }

  /**
   * Create transaction instruction for validator stake submission
   */
  private createValidatorStakeInstruction(
    validator: PublicKey,
    caseStudyPda: PublicKey,
    validatorStakePda: PublicKey,
    data: ValidationData
  ): TransactionInstruction {
    const instructionData = Buffer.alloc(500);
    let offset = 0;

    // Instruction discriminator (8 bytes)
    instructionData.writeUInt32LE(0x87654321, offset); // Placeholder
    offset += 8;

    // Validation type (1 byte)
    const validationTypeMap = { quality: 0, accuracy: 1, safety: 2 };
    instructionData.writeUInt8(validationTypeMap[data.validationType], offset);
    offset += 1;

    // Approved flag (1 byte)
    instructionData.writeUInt8(data.approved ? 1 : 0, offset);
    offset += 1;

    // Stake amount (8 bytes)
    const stakeAmountBN = new BN(data.stakeAmount * 1e6); // Convert to token units
    stakeAmountBN.toArrayLike(Buffer, 'le', 8).copy(instructionData, offset);
    offset += 8;

    // Noir proof (optional)
    if (data.noirProof && data.noirProof.length > 0) {
      instructionData.writeUInt16LE(data.noirProof.length, offset);
      offset += 2;
      data.noirProof.copy(instructionData, offset);
      offset += data.noirProof.length;
    } else {
      instructionData.writeUInt16LE(0, offset);
      offset += 2;
    }

    return new TransactionInstruction({
      keys: [
        { pubkey: validatorStakePda, isSigner: false, isWritable: true },
        { pubkey: caseStudyPda, isSigner: false, isWritable: true },
        { pubkey: validator, isSigner: true, isWritable: true },
        { pubkey: this.experienceMint, isSigner: false, isWritable: true },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.caseStudyProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Submit validator stake with ZK proof
   */
  async submitValidatorStake(
    validator: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    validationData: ValidationData
  ): Promise<TransactionResult> {
    try {
      // Derive PDA for validator stake
      const [validatorStakePda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('validator_stake'),
          validator.toBuffer(),
          validationData.caseStudyPubkey.toBuffer(),
        ],
        this.caseStudyProgramId
      );

      // Get validator's token account
      const validatorTokenAccount = await getAssociatedTokenAddress(
        this.experienceMint,
        validator
      );

      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');

      const transaction = new Transaction({
        feePayer: validator,
        recentBlockhash: blockhash,
      });

      // Add compute budget for ZK proof verification
      transaction.add(
        ComputeBudgetProgram.setComputeUnitLimit({
          units: 300_000,
        })
      );

      // Check if validator token account exists, create if not
      const tokenAccountInfo = await this.connection.getAccountInfo(validatorTokenAccount);
      if (!tokenAccountInfo) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            validator,
            validatorTokenAccount,
            validator,
            this.experienceMint
          )
        );
      }

      // Add validator stake instruction
      const stakeInstruction = this.createValidatorStakeInstruction(
        validator,
        validationData.caseStudyPubkey,
        validatorStakePda,
        validationData
      );
      transaction.add(stakeInstruction);

      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
        }
      );

      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash,
          lastValidBlockHeight: (await this.connection.getLatestBlockhash()).lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        throw new Error(`Validation transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }

      return {
        signature,
        accountPubkey: validatorStakePda,
        success: true,
      };
    } catch (error) {
      console.error('Validator stake submission error:', error);
      return {
        signature: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Reward user with EXPERIENCE tokens
   */
  async rewardExperienceTokens(
    authority: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    recipient: PublicKey,
    amount: number,
    reason: 'case_study_submission' | 'validation'
  ): Promise<string> {
    const transaction = new Transaction({
      feePayer: authority,
      recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
    });

    // In real usage, this would be an Anchor instruction to mint EXPERIENCE tokens
    // This is a placeholder

    const signedTx = await signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(
      signedTx.serialize()
    );

    await this.connection.confirmTransaction(signature, 'confirmed');

    return signature;
  }

  /**
   * Slash validator's EXPERIENCE tokens
   */
  async slashValidator(
    authority: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    validatorStakePubkey: PublicKey,
    reason: string
  ): Promise<string> {
    const transaction = new Transaction({
      feePayer: authority,
      recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
    });

    // In real usage, this would be an Anchor instruction to burn EXPERIENCE tokens
    // This is a placeholder

    const signedTx = await signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(
      signedTx.serialize()
    );

    await this.connection.confirmTransaction(signature, 'confirmed');

    return signature;
  }

  /**
   * Grant access permission to validator
   */
  async grantAccessPermission(
    payer: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    caseStudyPubkey: PublicKey,
    grantee: PublicKey,
    permissionType: number
  ): Promise<{
    accessPermissionPubkey: PublicKey;
    transactionSignature: string;
  }> {
    // Derive PDA for access permission
    const [accessPermissionPda] = await PublicKey.findProgramAddress(
      [
        Buffer.from('access_permission'),
        caseStudyPubkey.toBuffer(),
        grantee.toBuffer(),
      ],
      this.caseStudyProgramId
    );

    const transaction = new Transaction({
      feePayer: payer,
      recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
    });

    // Add instruction to grant access
    const instruction = SystemProgram.createAccount({
      fromPubkey: payer,
      newAccountPubkey: accessPermissionPda,
      lamports: await this.connection.getMinimumBalanceForRentExemption(
        8 + 32 + 32 + 1 + 8
      ),
      space: 8 + 32 + 32 + 1 + 8,
      programId: this.caseStudyProgramId,
    });

    transaction.add(instruction);

    const signedTx = await signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(
      signedTx.serialize()
    );

    await this.connection.confirmTransaction(signature, 'confirmed');

    return {
      accessPermissionPubkey: accessPermissionPda,
      transactionSignature: signature,
    };
  }

  /**
   * Get all case studies for a patient with pagination
   */
  async getCaseStudiesForPatient(
    patientPubkey: PublicKey,
    limit: number = 10
  ): Promise<PublicKey[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.caseStudyProgramId,
        {
          filters: [
            {
              memcmp: {
                offset: 8, // Skip discriminator
                bytes: patientPubkey.toBase58(),
              },
            },
          ],
          dataSlice: {
            offset: 0,
            length: 0, // Only get pubkeys
          },
        }
      );

      return accounts
        .map((account) => account.pubkey)
        .slice(0, limit);
    } catch (error) {
      console.error('Error getting case studies:', error);
      return [];
    }
  }

  /**
   * Get all validator stakes for a case study
   */
  async getValidatorStakesForCaseStudy(
    caseStudyPubkey: PublicKey
  ): Promise<PublicKey[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.caseStudyProgramId,
        {
          filters: [
            {
              memcmp: {
                offset: 40, // Skip discriminator + patient_id
                bytes: caseStudyPubkey.toBase58(),
              },
            },
          ],
        }
      );

      return accounts.map((account) => account.pubkey);
    } catch (error) {
      console.error('Error getting validator stakes:', error);
      return [];
    }
  }

  /**
   * Get network status and health
   */
  async getNetworkStatus(): Promise<{
    blockHeight: number;
    health: 'ok' | 'behind' | 'unknown';
    tps: number;
  }> {
    try {
      const blockHeight = await this.connection.getBlockHeight();
      const health = await this.connection.getHealth();

      // Get recent performance samples for TPS calculation
      const perfSamples = await this.connection.getRecentPerformanceSamples(1);
      const tps = perfSamples.length > 0 ? perfSamples[0].numTransactions / perfSamples[0].samplePeriodSecs : 0;

      return {
        blockHeight,
        health: health === 'ok' ? 'ok' : 'behind',
        tps: Math.round(tps),
      };
    } catch (error) {
      console.error('Error getting network status:', error);
      return {
        blockHeight: 0,
        health: 'unknown',
        tps: 0,
      };
    }
  }

  /**
   * Estimate transaction fees
   */
  async estimateTransactionFee(transaction: Transaction): Promise<number> {
    try {
      const feeCalculator = await this.connection.getFeeForMessage(
        transaction.compileMessage(),
        'confirmed'
      );
      return feeCalculator.value || 5000; // Default 5000 lamports
    } catch (error) {
      console.error('Error estimating fee:', error);
      return 5000; // Default fallback
    }
  }
}
