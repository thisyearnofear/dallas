/**
 * Enhanced Blockchain Service for Dallas Buyers Club
 * 
 * Handles interactions with Solana smart contracts:
 * - Case study submission with ZK proofs
 * - Validator staking & slashing mechanism
 * - DBC token operations (staking, rewards)
 * - Privacy sponsor integrations (Light Protocol, Arcium, etc.)
 * 
 * Privacy-first design:
 * - All health data encrypted before blockchain submission
 * - Platform cannot decrypt without user permission
 * - On-chain access control (patient-granted)
 */

import {
  PublicKey,
  Connection,
  Transaction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  TransactionInstruction,
  ComputeBudgetProgram,
} from '@solana/web3.js';
import { Program, AnchorProvider, BN, web3 } from '@coral-xyz/anchor';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress, createAssociatedTokenAccountInstruction } from '@solana/spl-token';
import { SOLANA_CONFIG } from '../config/solana';

export interface CaseStudyData {
  encryptedBaseline: Uint8Array;
  encryptedOutcome: Uint8Array;
  treatmentProtocol: string;
  durationDays: number;
  costUSD: number;
  // Privacy sponsor integration fields
  lightProtocolProof?: Uint8Array;
  compressionRatio?: number;
  noirCircuitId?: Uint8Array;
  arciumMpcParams?: Uint8Array;
  usePrivacyCash?: boolean;
  useShadowWire?: boolean;
}

export interface ValidationData {
  caseStudyPubkey: PublicKey;
  validationType: 'quality' | 'accuracy' | 'safety';
  approved: boolean;
  stakeAmount: number;
  // ZK proof for validation without decryption
  noirProof?: Uint8Array;
  circuitParamsHash?: Uint8Array;
}

export interface TransactionResult {
  signature: string;
  accountPubkey?: PublicKey;
  success: boolean;
  error?: string;
}

export interface CaseStudyAccount {
  patientId: PublicKey;
  encryptedBaseline: Uint8Array;
  encryptedOutcome: Uint8Array;
  treatmentProtocol: string;
  durationDays: number;
  costUsd: number;
  createdAt: number;
  isApproved: boolean;
  approvalCount: number;
  validationScore: number;
  bump: number;
}

export class BlockchainService {
  private connection: Connection;
  private caseStudyProgramId: PublicKey;
  private dbcMint: PublicKey;
  private tokenProgramId: PublicKey;

  /**
   * Initialize BlockchainService with program addresses from config
   */
  constructor() {
    this.connection = new Connection(SOLANA_CONFIG.rpcEndpoint[SOLANA_CONFIG.network], 'confirmed');
    this.caseStudyProgramId = new PublicKey(SOLANA_CONFIG.blockchain.caseStudyProgramId);
    this.dbcMint = new PublicKey(SOLANA_CONFIG.blockchain.dbcMintAddress);
    this.tokenProgramId = new PublicKey(SOLANA_CONFIG.blockchain.dbcTokenProgramId);
  }

  /**
   * Create transaction instruction for case study submission
   * Includes privacy sponsor integrations
   */
  private createSubmitCaseStudyInstruction(
    payer: PublicKey,
    caseStudyPda: PublicKey,
    data: CaseStudyData
  ): TransactionInstruction {
    // Create instruction data buffer
    const instructionData = Buffer.alloc(1000); // Adjust size as needed
    let offset = 0;

    // Instruction discriminator (8 bytes) - this would be generated by Anchor
    instructionData.writeUInt32LE(0x12345678, offset); // Placeholder
    offset += 8;

    // IPFS CID placeholder (46 bytes)
    const ipfsCid = `Qm${Math.random().toString(36).substring(2, 46)}`;
    instructionData.write(ipfsCid, offset);
    offset += 46;

    // Metadata hash (32 bytes)
    const metadataHash = Buffer.from(Array(32).fill(0).map(() => Math.floor(Math.random() * 256)));
    metadataHash.copy(instructionData, offset);
    offset += 32;

    // Treatment category (1 byte)
    instructionData.writeUInt8(0, offset); // 0=experimental
    offset += 1;

    // Duration days (2 bytes)
    instructionData.writeUInt16LE(data.durationDays, offset);
    offset += 2;

    // Light Protocol proof (optional)
    if (data.lightProtocolProof && data.lightProtocolProof.length > 0) {
      instructionData.writeUInt16LE(data.lightProtocolProof.length, offset);
      offset += 2;
      data.lightProtocolProof.copy(instructionData, offset);
      offset += data.lightProtocolProof.length;
    } else {
      instructionData.writeUInt16LE(0, offset);
      offset += 2;
    }

    // Compression ratio
    instructionData.writeUInt16LE(data.compressionRatio || 1, offset);
    offset += 2;

    return new TransactionInstruction({
      keys: [
        { pubkey: caseStudyPda, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
      ],
      programId: this.caseStudyProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Submit encrypted case study to blockchain with privacy sponsor integrations
   */
  async submitCaseStudy(
    payer: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    caseStudyData: CaseStudyData
  ): Promise<TransactionResult> {
    try {
      // Derive PDA for case study account
      const timestamp = Math.floor(Date.now() / 1000);
      const [caseStudyPda, bump] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('case_study'),
          payer.toBuffer(),
          Buffer.from(timestamp.toString()),
        ],
        this.caseStudyProgramId
      );

      // Get recent blockhash
      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');

      // Create transaction
      const transaction = new Transaction({
        feePayer: payer,
        recentBlockhash: blockhash,
      });

      // Add compute budget instruction for complex operations
      transaction.add(
        ComputeBudgetProgram.setComputeUnitLimit({
          units: 400_000, // Increase for ZK proof verification
        })
      );

      // Add case study submission instruction
      const submitInstruction = this.createSubmitCaseStudyInstruction(
        payer,
        caseStudyPda,
        caseStudyData
      );
      transaction.add(submitInstruction);

      // Sign and send transaction
      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
        }
      );

      // Wait for confirmation
      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash,
          lastValidBlockHeight: (await this.connection.getLatestBlockhash()).lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }

      return {
        signature,
        accountPubkey: caseStudyPda,
        success: true,
      };
    } catch (error) {
      console.error('Case study submission error:', error);
      return {
        signature: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Fetch case study from blockchain
   */
  async fetchCaseStudy(caseStudyPubkey: PublicKey): Promise<CaseStudyAccount | null> {
    try {
      const accountInfo = await this.connection.getAccountInfo(caseStudyPubkey);
      if (!accountInfo) return null;

      // Decode account data (simplified - in real usage, use Anchor client)
      const data = accountInfo.data;

      // This is a placeholder - actual decoding would parse the Anchor account structure
      return {
        patientId: new PublicKey(data.slice(8, 40)),
        encryptedBaseline: new Uint8Array(data.slice(40, 10044)),
        encryptedOutcome: new Uint8Array(data.slice(10044, 20048)),
        treatmentProtocol: Buffer.from(data.slice(20048, 20552)).toString(),
        durationDays: data.readUInt32LE(20552),
        costUsd: data.readUInt32LE(20556),
        createdAt: Number(data.readBigInt64LE(20560)),
        isApproved: data[20568] === 1,
        approvalCount: data.readUInt32LE(20569),
        validationScore: data.readUInt32LE(20573),
        bump: data[20577],
      };
    } catch (error) {
      console.error('Error fetching case study:', error);
      return null;
    }
  }

  /**
   * Create transaction instruction for validator stake submission
   */
  private createValidatorStakeInstruction(
    validator: PublicKey,
    caseStudyPda: PublicKey,
    validatorStakePda: PublicKey,
    data: ValidationData
  ): TransactionInstruction {
    const instructionData = Buffer.alloc(500);
    let offset = 0;

    // Instruction discriminator (8 bytes)
    instructionData.writeUInt32LE(0x87654321, offset); // Placeholder
    offset += 8;

    // Validation type (1 byte)
    const validationTypeMap = { quality: 0, accuracy: 1, safety: 2 };
    instructionData.writeUInt8(validationTypeMap[data.validationType], offset);
    offset += 1;

    // Approved flag (1 byte)
    instructionData.writeUInt8(data.approved ? 1 : 0, offset);
    offset += 1;

    // Stake amount (8 bytes)
    const stakeAmountBN = new BN(data.stakeAmount * 1e6); // Convert to token units
    stakeAmountBN.toArrayLike(Buffer, 'le', 8).copy(instructionData, offset);
    offset += 8;

    // Noir proof (optional)
    if (data.noirProof && data.noirProof.length > 0) {
      instructionData.writeUInt16LE(data.noirProof.length, offset);
      offset += 2;
      data.noirProof.copy(instructionData, offset);
      offset += data.noirProof.length;
    } else {
      instructionData.writeUInt16LE(0, offset);
      offset += 2;
    }

    return new TransactionInstruction({
      keys: [
        { pubkey: validatorStakePda, isSigner: false, isWritable: true },
        { pubkey: caseStudyPda, isSigner: false, isWritable: true },
        { pubkey: validator, isSigner: true, isWritable: true },
        { pubkey: this.dbcMint, isSigner: false, isWritable: true },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.caseStudyProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Submit validator stake with ZK proof
   */
  async submitValidatorStake(
    validator: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    validationData: ValidationData
  ): Promise<TransactionResult> {
    try {
      // Derive PDA for validator stake
      const [validatorStakePda] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('validator_stake'),
          validator.toBuffer(),
          validationData.caseStudyPubkey.toBuffer(),
        ],
        this.caseStudyProgramId
      );

      // Get validator's token account
      const validatorTokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        validator
      );

      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');

      const transaction = new Transaction({
        feePayer: validator,
        recentBlockhash: blockhash,
      });

      // Add compute budget for ZK proof verification
      transaction.add(
        ComputeBudgetProgram.setComputeUnitLimit({
          units: 300_000,
        })
      );

      // Check if validator token account exists, create if not
      const tokenAccountInfo = await this.connection.getAccountInfo(validatorTokenAccount);
      if (!tokenAccountInfo) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            validator,
            validatorTokenAccount,
            validator,
            this.dbcMint
          )
        );
      }

      // Add validator stake instruction
      const stakeInstruction = this.createValidatorStakeInstruction(
        validator,
        validationData.caseStudyPubkey,
        validatorStakePda,
        validationData
      );
      transaction.add(stakeInstruction);

      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
        }
      );

      const confirmation = await this.connection.confirmTransaction(
        {
          signature,
          blockhash,
          lastValidBlockHeight: (await this.connection.getLatestBlockhash()).lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        throw new Error(`Validation transaction failed: ${JSON.stringify(confirmation.value.err)}`);
      }

      return {
        signature,
        accountPubkey: validatorStakePda,
        success: true,
      };
    } catch (error) {
      console.error('Validator stake submission error:', error);
      return {
        signature: '',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Reward user with DBC tokens using the deployed program
   */
  async rewardDBCTokens(
    authority: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    recipient: PublicKey,
    amount: number,
    reason: 'case_study_submission' | 'validation',
    qualityScore?: number,
    usePrivacyCash?: boolean,
    useShadowWire?: boolean
  ): Promise<string> {
    try {
      // Import required SPL token utilities
      const { getAssociatedTokenAddress, createAssociatedTokenAccountInstruction } = await import('@solana/spl-token');

      // Get recipient's token account
      const recipientTokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        recipient
      );

      // Get authority's token account (for mint authority)
      const authorityTokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        authority
      );

      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');
      const transaction = new Transaction({
        feePayer: authority,
        recentBlockhash: blockhash,
      });

      // Check if recipient token account exists, create if not
      const recipientAccountInfo = await this.connection.getAccountInfo(recipientTokenAccount);
      if (!recipientAccountInfo) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            authority,
            recipientTokenAccount,
            recipient,
            this.dbcMint
          )
        );
      }

      // Create instruction to call the DBC Token program
      // This would use the actual Anchor-generated instruction
      const rewardInstruction = this.createRewardDBCInstruction(
        authority,
        recipient,
        recipientTokenAccount,
        amount,
        reason,
        qualityScore,
        usePrivacyCash,
        useShadowWire
      );
      
      transaction.add(rewardInstruction);

      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        { skipPreflight: false, preflightCommitment: 'confirmed' }
      );

      await this.connection.confirmTransaction(signature, 'confirmed');

      return signature;
    } catch (error) {
      console.error('Error rewarding DBC tokens:', error);
      throw error;
    }
  }

  /**
   * Create instruction for rewarding DBC tokens
   */
  private createRewardDBCInstruction(
    authority: PublicKey,
    recipient: PublicKey,
    recipientTokenAccount: PublicKey,
    amount: number,
    reason: 'case_study_submission' | 'validation',
    qualityScore?: number,
    usePrivacyCash?: boolean,
    useShadowWire?: boolean
  ): TransactionInstruction {
    // Convert amount to token units (assuming 6 decimals)
    const amountInUnits = Math.floor(amount * 1_000_000); // 1 DBC = 1,000,000 units

    // Determine instruction discriminator based on reason
    const discriminator = reason === 'case_study_submission' ? 0x01 : 0x02;

    // Create instruction data
    const instructionData = Buffer.alloc(100);
    let offset = 0;

    // Instruction discriminator (8 bytes)
    instructionData.writeUInt32LE(discriminator, offset);
    offset += 8;

    // Amount (8 bytes)
    instructionData.writeBigUInt64LE(BigInt(amountInUnits), offset);
    offset += 8;

    // Quality score (1 byte, for case study submissions)
    if (reason === 'case_study_submission') {
      instructionData.writeUInt8(qualityScore || 0, offset);
      offset += 1;
    }

    // Privacy flags (2 bytes)
    const privacyFlags = (usePrivacyCash ? 0x01 : 0x00) | (useShadowWire ? 0x02 : 0x00);
    instructionData.writeUInt16LE(privacyFlags, offset);
    offset += 2;

    return new TransactionInstruction({
      keys: [
        { pubkey: this.tokenProgramId, isSigner: false, isWritable: false },
        { pubkey: this.dbcMint, isSigner: false, isWritable: true },
        { pubkey: recipientTokenAccount, isSigner: false, isWritable: true },
        { pubkey: recipient, isSigner: false, isWritable: false },
        { pubkey: authority, isSigner: true, isWritable: false },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      ],
      programId: this.tokenProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Stake DBC tokens for validation
   */
  async stakeDBCTokens(
    validator: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    amount: number,
    caseStudyPubkey: PublicKey,
    shieldAmount: boolean = false
  ): Promise<string> {
    try {
      const { getAssociatedTokenAddress, createAssociatedTokenAccountInstruction } = await import('@solana/spl-token');

      // Get validator's token account
      const validatorTokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        validator
      );

      // Derive stake escrow account
      const [stakeEscrow, stakeEscrowBump] = PublicKey.findProgramAddressSync(
        [
          Buffer.from('stake_escrow'),
          validator.toBuffer(),
          caseStudyPubkey.toBuffer(),
        ],
        this.tokenProgramId
      );

      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');
      const transaction = new Transaction({
        feePayer: validator,
        recentBlockhash: blockhash,
      });

      // Check if validator token account exists, create if not
      const tokenAccountInfo = await this.connection.getAccountInfo(validatorTokenAccount);
      if (!tokenAccountInfo) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            validator,
            validatorTokenAccount,
            validator,
            this.dbcMint
          )
        );
      }

      // Check if stake escrow exists, create if not
      const escrowAccountInfo = await this.connection.getAccountInfo(stakeEscrow);
      if (!escrowAccountInfo) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            validator,
            stakeEscrow,
            validator,
            this.dbcMint
          )
        );
      }

      // Add stake instruction
      const stakeInstruction = this.createStakeInstruction(
        validator,
        validatorTokenAccount,
        stakeEscrow,
        amount,
        caseStudyPubkey,
        shieldAmount
      );
      
      transaction.add(stakeInstruction);

      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        { skipPreflight: false, preflightCommitment: 'confirmed' }
      );

      await this.connection.confirmTransaction(signature, 'confirmed');

      return signature;
    } catch (error) {
      console.error('Error staking DBC tokens:', error);
      throw error;
    }
  }

  /**
   * Create instruction for staking DBC tokens
   */
  private createStakeInstruction(
    validator: PublicKey,
    validatorTokenAccount: PublicKey,
    stakeEscrow: PublicKey,
    amount: number,
    caseStudyPubkey: PublicKey,
    shieldAmount: boolean
  ): TransactionInstruction {
    const amountInUnits = Math.floor(amount * 1_000_000);

    const instructionData = Buffer.alloc(50);
    let offset = 0;

    // Instruction discriminator for stake (0x03)
    instructionData.writeUInt32LE(0x03, offset);
    offset += 8;

    // Amount (8 bytes)
    instructionData.writeBigUInt64LE(BigInt(amountInUnits), offset);
    offset += 8;

    // Shield amount flag (1 byte)
    instructionData.writeUInt8(shieldAmount ? 1 : 0, offset);
    offset += 1;

    return new TransactionInstruction({
      keys: [
        { pubkey: this.tokenProgramId, isSigner: false, isWritable: false },
        { pubkey: this.dbcMint, isSigner: false, isWritable: true },
        { pubkey: validatorTokenAccount, isSigner: false, isWritable: true },
        { pubkey: stakeEscrow, isSigner: false, isWritable: true },
        { pubkey: validator, isSigner: true, isWritable: false },
        { pubkey: caseStudyPubkey, isSigner: false, isWritable: true },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      ],
      programId: this.tokenProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Slash validator's DBC tokens
   */
  async slashValidator(
    authority: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    validatorStakePubkey: PublicKey,
    slashPercentage: number,
    evidenceHash: Uint8Array,
    reason: string
  ): Promise<string> {
    try {
      const { getAssociatedTokenAddress } = await import('@solana/spl-token');

      // Get treasury token account
      const treasuryPubkey = new PublicKey(SOLANA_CONFIG.treasuryAddress);
      const treasuryTokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        treasuryPubkey
      );

      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');
      const transaction = new Transaction({
        feePayer: authority,
        recentBlockhash: blockhash,
      });

      // Add slash instruction
      const slashInstruction = this.createSlashInstruction(
        authority,
        validatorStakePubkey,
        treasuryTokenAccount,
        slashPercentage,
        evidenceHash,
        reason
      );
      
      transaction.add(slashInstruction);

      const signedTx = await signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(
        signedTx.serialize(),
        { skipPreflight: false, preflightCommitment: 'confirmed' }
      );

      await this.connection.confirmTransaction(signature, 'confirmed');

      return signature;
    } catch (error) {
      console.error('Error slashing validator:', error);
      throw error;
    }
  }

  /**
   * Create instruction for slashing validator stake
   */
  private createSlashInstruction(
    authority: PublicKey,
    validatorStakePubkey: PublicKey,
    treasuryTokenAccount: PublicKey,
    slashPercentage: number,
    evidenceHash: Uint8Array,
    reason: string
  ): TransactionInstruction {
    const instructionData = Buffer.alloc(100);
    let offset = 0;

    // Instruction discriminator for slash (0x04)
    instructionData.writeUInt32LE(0x04, offset);
    offset += 8;

    // Slash percentage (1 byte)
    instructionData.writeUInt8(Math.min(100, Math.max(0, slashPercentage)), offset);
    offset += 1;

    // Evidence hash (32 bytes)
    if (evidenceHash.length === 32) {
      evidenceHash.copy(instructionData, offset);
    }
    offset += 32;

    // Reason (variable length, max 50 bytes)
    const reasonBuffer = Buffer.from(reason.slice(0, 50));
    instructionData.writeUInt8(reasonBuffer.length, offset);
    offset += 1;
    reasonBuffer.copy(instructionData, offset);
    offset += reasonBuffer.length;

    return new TransactionInstruction({
      keys: [
        { pubkey: this.tokenProgramId, isSigner: false, isWritable: false },
        { pubkey: this.dbcMint, isSigner: false, isWritable: true },
        { pubkey: validatorStakePubkey, isSigner: false, isWritable: true },
        { pubkey: treasuryTokenAccount, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: true, isWritable: false },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      ],
      programId: this.tokenProgramId,
      data: instructionData.slice(0, offset),
    });
  }

  /**
   * Grant access permission to validator
   */
  async grantAccessPermission(
    payer: PublicKey,
    signTransaction: (tx: Transaction) => Promise<Transaction>,
    caseStudyPubkey: PublicKey,
    grantee: PublicKey,
    permissionType: number
  ): Promise<{
    accessPermissionPubkey: PublicKey;
    transactionSignature: string;
  }> {
    // Derive PDA for access permission
    const [accessPermissionPda] = await PublicKey.findProgramAddress(
      [
        Buffer.from('access_permission'),
        caseStudyPubkey.toBuffer(),
        grantee.toBuffer(),
      ],
      this.caseStudyProgramId
    );

    const transaction = new Transaction({
      feePayer: payer,
      recentBlockhash: (await this.connection.getLatestBlockhash()).blockhash,
    });

    // Add instruction to grant access
    const instruction = SystemProgram.createAccount({
      fromPubkey: payer,
      newAccountPubkey: accessPermissionPda,
      lamports: await this.connection.getMinimumBalanceForRentExemption(
        8 + 32 + 32 + 1 + 8
      ),
      space: 8 + 32 + 32 + 1 + 8,
      programId: this.caseStudyProgramId,
    });

    transaction.add(instruction);

    const signedTx = await signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(
      signedTx.serialize()
    );

    await this.connection.confirmTransaction(signature, 'confirmed');

    return {
      accessPermissionPubkey: accessPermissionPda,
      transactionSignature: signature,
    };
  }

  /**
   * Get all case studies for a patient with pagination
   */
  async getCaseStudiesForPatient(
    patientPubkey: PublicKey,
    limit: number = 10
  ): Promise<PublicKey[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.caseStudyProgramId,
        {
          filters: [
            {
              memcmp: {
                offset: 8, // Skip discriminator
                bytes: patientPubkey.toBase58(),
              },
            },
          ],
          dataSlice: {
            offset: 0,
            length: 0, // Only get pubkeys
          },
        }
      );

      return accounts
        .map((account) => account.pubkey)
        .slice(0, limit);
    } catch (error) {
      console.error('Error getting case studies:', error);
      return [];
    }
  }

  /**
   * Get all validator stakes for a case study
   */
  async getValidatorStakesForCaseStudy(
    caseStudyPubkey: PublicKey
  ): Promise<PublicKey[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.caseStudyProgramId,
        {
          filters: [
            {
              memcmp: {
                offset: 40, // Skip discriminator + patient_id
                bytes: caseStudyPubkey.toBase58(),
              },
            },
          ],
        }
      );

      return accounts.map((account) => account.pubkey);
    } catch (error) {
      console.error('Error getting validator stakes:', error);
      return [];
    }
  }

  /**
   * Get DBC token balance for a wallet
   */
  async getDBCTokenBalance(walletPubkey: PublicKey): Promise<number> {
    try {
      const { getAssociatedTokenAddress } = await import('@solana/spl-token');
      const tokenAccount = await getAssociatedTokenAddress(
        this.dbcMint,
        walletPubkey
      );

      const accountInfo = await this.connection.getTokenAccountBalance(tokenAccount);
      return Number(accountInfo.value.uiAmount) || 0;
    } catch (error) {
      console.error('Error getting DBC token balance:', error);
      return 0;
    }
  }

  /**
   * Get DBC token transaction history
   */
  async getDBCTokenTransactions(walletPubkey: PublicKey, limit: number = 10): Promise<Array<{
    signature: string;
    amount: number;
    type: 'reward' | 'stake' | 'slash' | 'transfer';
    timestamp: number;
    status: 'success' | 'failed';
  }>> {
    try {
      // In a real implementation, this would query the program accounts
      // For now, return mock data
      return [
        {
          signature: '5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbXp5Xp9Dv5Mf',
          amount: 25.5,
          type: 'reward',
          timestamp: Date.now() - 86400000,
          status: 'success'
        },
        {
          signature: '3ZJwXJzLp7XqTzJwXJzLp7XqTzJwXJzLp7XqTzJwXJzLp7XqTz',
          amount: 10.0,
          type: 'stake',
          timestamp: Date.now() - 172800000,
          status: 'success'
        }
      ];
    } catch (error) {
      console.error('Error getting DBC token transactions:', error);
      return [];
    }
  }

  /**
   * Get network status and health
   */
  async getNetworkStatus(): Promise<{
    blockHeight: number;
    health: 'ok' | 'behind' | 'unknown';
    tps: number;
  }> {
    try {
      const blockHeight = await this.connection.getBlockHeight();
      const health = await this.connection.getHealth();

      // Get recent performance samples for TPS calculation
      const perfSamples = await this.connection.getRecentPerformanceSamples(1);
      const tps = perfSamples.length > 0 ? perfSamples[0].numTransactions / perfSamples[0].samplePeriodSecs : 0;

      return {
        blockHeight,
        health: health === 'ok' ? 'ok' : 'behind',
        tps: Math.round(tps),
      };
    } catch (error) {
      console.error('Error getting network status:', error);
      return {
        blockHeight: 0,
        health: 'unknown',
        tps: 0,
      };
    }
  }

  /**
   * Estimate transaction fees
   */
  async estimateTransactionFee(transaction: Transaction): Promise<number> {
    try {
      const feeCalculator = await this.connection.getFeeForMessage(
        transaction.compileMessage(),
        'confirmed'
      );
      return feeCalculator.value || 5000; // Default 5000 lamports
    } catch (error) {
      console.error('Error estimating fee:', error);
      return 5000; // Default fallback
    }
  }
}
